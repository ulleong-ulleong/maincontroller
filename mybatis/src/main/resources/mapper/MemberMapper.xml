<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="ksmart.mybatis.mapper.MemberMapper">
	
	<!-- ResultMap : DTO와 DB와 조회된 결과 맵핑 객체 -->
	<resultMap type="MemberLevel" id="memberLevelResultMap">
		<!-- pk == id  -->
		<id property="levelNum" column="level_num" />
		<!-- pk 제외한 모든 컬럼 == result -->
		<result property="levelName" 	column="level_name"/>
		<result property="levelRegDate" column="level_reg_date"/>
	</resultMap>
	
	<resultMap type="Member" id="memberResultMap">
		<id 	property="memberId" 			column="m_id"/>
		<result property="memberPw" 			column="m_pw"/>
		<result property="memberName" 			column="m_name"/>
		<result property="memberLevel" 			column="m_level"/>
		<result property="memberLevelName" 		column="m_level_name"/>
		<!-- 검색 조건에 따른 회원 목록과 연결되는 게 없어 새로 name 생성 -->
		<result property="memberEmail" 			column="m_email"/>
		<result property="memberAddr" 			column="m_addr"/>
		<result property="memberRegDate" 		column="m_reg_date"/>
		
		<!-- 고급 매핑. 1:N Collection(관계)
			ex: List<Goods> goodsList
			Member.dto -> MemberMapper.java 다음. -->
		<collection property="goodsList" javaType = "List" ofType="Goods">
			<!-- pk == id  -->
			<id property="goodsCode" column="g_code" />
			<!-- pk 제외한 모든 컬럼 == result -->
			<result property="goodsName" 		column="g_name"/>
			<result property="goodsPrice" 		column="g_price"/>
			<result property="goodsSellerId" 	column="g_seller_id"/>
			<result property="goodsRegDate" 	column="g_reg_date"/>
		</collection>
	</resultMap>
	
	<resultMap type="LoginHistory" id="loginHistoryResultMap">
		<id property="loginNum" column="login_num" />
		<result property="loginId" column="login_id" />
		<result property="loginDate" column="login_date" />
		<result property="logoutDate" column="logout_date" />
		<association property="member">
			<id 	property="memberId" 			column="m_id"/>
			<result property="memberPw" 			column="m_pw"/>
			<result property="memberName" 			column="m_name"/>
			<result property="memberLevel" 			column="m_level"/>
			<result property="memberLevelName" 		column="m_level_name"/>
			<result property="memberEmail" 			column="m_email"/>
			<result property="memberAddr" 			column="m_addr"/>
			<result property="memberRegDate" 		column="m_reg_date"/>
		</association>
	</resultMap>
	<!-- 로그인 이력 조회, int가 2개를 동시에 받을 수 없어 Map을 이용해야 한다. -->
	<select id="getLoginHistory" parameterType="String" resultMap="loginHistoryResultMap">
	/*로그인 이력 조회, 페이징 처리*/
	SELECT
		l.login_num,
		l.login_id,
		m.m_name,
		m.m_email,
		l.login_date,
		l.logout_date
	FROM
		tb_login AS l
		INNER JOIN
		tb_member AS m
		ON
		l.login_id = m.m_id
	ORDER BY l.login_num DESC
	<if test="startRowNum > -1">
		LIMIT #{startRowNum}, #{rowPerPage};
	</if>
	</select>
	<!-- 로그인 이력 전체 행의 개수 -->
	<select id="getLoginHistoryCnt" resultType="int">
	/*로그인 이력 전체 행의 개수*/
	SELECT
		COUNT(1)
	FROM
		tb_login;
	
	</select>
	
	<!-- 판매자 현황 -->
	<select id="getSellerList" resultMap="memberResultMap">
	SELECT
		m.m_id,
		m.m_pw,
		m.m_name,
		m.m_level,
		m.m_email,
		m.m_addr,
		m.m_reg_date,
		g.g_code,
		g.g_name,
		g.g_price,
		g.g_seller_id,
		g.g_reg_date
	FROM
		tb_goods AS g
		INNER JOIN
		tb_member AS m
		ON
		g.g_seller_id = m.m_id
	ORDER BY m_id;
	
	</select>
	<!-- 검색 조건에 따른 회원 목록 -->
	<select id="getMemberListBySearch" parameterType="String" resultMap="memberResultMap">
		/*검색 조건에 따른 회원 목록*/
		SELECT
			m.m_id,
			m.m_pw,
			m.m_name,
			IFNULL(m.m_level, 0) AS m_level,
			l.level_name AS m_level_name,
			m.m_email,
			m.m_addr,
			m.m_reg_date
		FROM
			tb_member AS m
			INNER JOIN
			tb_member_level AS l
			ON
			m.m_level = l.level_num
			<!-- 동적 쿼리 where문을 작성, 그리고 동적 쿼리에선 && 대신 and를 사용
			     유효성 검증 -->
			    <!-- #은 searchValue 양 옆으로 ' '가 생기면서 값을 비교하는 것. -->
			<where>
				<if test="searchKey != null and searchKey != ''">
					${searchKey} LIKE CONCAT('%', #{searchValue}, '%'); 
				</if>
			</where>
	</select>
	
	<!-- 특정 회원 탈퇴, interface -> xml -> MemberService로 이동 --> 
	<delete id="removeMemberById" parameterType="String">
	/* 특정 회원 탈퇴*/
	DELETE
	FROM
		tb_member
	WHERE
		m_id = #{memberId};
	</delete>
	
	<!-- 특정 회원 로그인 이력 삭제 -->
	<delete id="removeLoginHistoryById" parameterType="String">
	/*특정 회원 로그인 이력 삭제*/
	DELETE
	FROM
		tb_login
	WHERE
		login_id = #{memberId};
	</delete>
	
	<!-- 구매자가 구매한 이력 삭제 -->
	<delete id="removeOrderByOrderId" parameterType="String">
	/*구매자가 구매한 이력 삭제*/
	DELETE
	FROM
		tb_order
	WHERE
		o_id = #{orderId};
	</delete>
	
	<!-- 판매자가 등록한 상품 삭제-->
	<delete id="removeGoodsById" parameterType = "String">
	/* 판매자가 등록한 상품 삭제 */
	DELETE
	FROM
		tb_goods
	WHERE
		g_seller_id = 'id007';
	<!-- FROM에 AS를 넣을 거라면 어떤 타겟을 삭제할 것인지에 대해 DELETE에 넣어줘야 하고
		그게 아니라면 AS를 삭제해야한다. -->
	</delete>
	
	<!-- 판매자가 등록한 상품을 주문한 이력삭제 -->
	<delete id="removeOrderBySellerId" parameterType = "String">
		/*판매자가 등록한 상품을 주문한 이력삭제*/
		DELETE
			o
		FROM
			tb_goods AS g
			INNER JOIN
			tb_order AS o
			ON
			g.g_code = o.o_g_code
		WHERE
			g.g_seller_id = #{sellerId};
		<!-- <WHERE></WHERE>를 사용하지 않는 이유 : 동적구문을 작성할 경우 잘못하면 다른 것까지 다 지우는 현상이 나타나므로 차라리 에러가 나으니까. -->
	</delete>
	
	<!-- mybatis에서 동적SQL 구문 만들 것 -->
	<!-- 동적SQL 구문 : if(조건문), choose(when, otherwise = 조건문), trim(where, set = 생성), forEach(반복문) -->
	<!-- https://mybatis.org/mybatis-3/ko/dynamic-sql.html -->
	<!-- 특정회원 수정 -->
	<update id="modifyMember" parameterType="Member">
		UPDATE tb_member
		<set>
		<!-- <trim prefix="SET" suffixOverrides=",">  -->
			<if test="memberPw != null and memberPw != ''">
				m_pw = #{memberPw},
			</if>
			<if test="memberName != null and memberName != ''">
				m_name = #{memberName},
			</if>
			<if test="memberLevel != null and memberLevel != ''">
				m_level = #{memberLevel},
			</if>
			<if test="memberEmail != null and memberEmail != ''">
				m_email = #{memberEmail},
			</if>
			<if test="memberAddr != null and memberAddr != ''">
				m_addr = #{memberAddr}
			</if>
		</set>
		<!-- </trim>  -->
		<!-- trim은 prefix와 suffixOverrides 구문을 작성했지만 set은 딱 3글자만 작성했을 뿐인데 동적 SQL구문이 작동되었다. -->
		WHERE
			m_id = #{memberId};
		<!-- trim에도 where를 태그로 할 수 있는데 왜 안했을까? : 위험해서 memberId가 누락되어 DB 데이터가 전부 update가 될 수도 있기 떄문에.
			trim에서 where 조건은 select에서만 사용된다. select는 조회만 할 뿐 데이터를 건들지 않으니까. -->
	<!-- 위 경우 문제점 : 하나만 변경하고 싶지만 다른 모든 것도 전부 작성해줘야 한다. 이유는 쉼표 때문이다. 끝이 주소로 끝나면 상관 없지만 주소를 제외한 나머지로 끝나면 마지막이 쉼표기 때문에 구문 오류가 발생한다.-->
	<!-- 내가 원하는 컬럼만 변경할 수 있도록 하는 것이 동적 SQL이다. -->	
	</update>
	
	<!-- 특정회원 조회 -->
	<select id="getMemberInfoById" parameterType="String" resultMap="memberResultMap">
		/*특정회원 조회*/
		SELECT
			m.m_id,
			m.m_pw,
			m.m_name,
			IFNULL(m.m_level, 0) AS m_level,
			m.m_email,
			m.m_addr,
			m.m_reg_date
		FROM
			tb_member AS m
		WHERE
			m.m_id = #{memberId};
	</select>
	
	
	<!-- 회원가입 -->
	<insert id="addMember" parameterType="Member">
		/* 회원가입 */
		INSERT INTO tb_member
		(m_id, m_pw, m_name, m_level, m_email, m_addr, m_reg_date)
		VALUES 
		(#{memberId}, #{memberPw}, #{memberName}, #{memberLevel}, #{memberEmail}, #{memberAddr}, CURDATE())
	</insert>
	
	<!-- 회원아이디 중복체크 -->
	<select id="idCheck" parameterType="String" resultType="boolean">
		/* 회원아이디 중복체크 */
		SELECT 
			count(m.m_id)
		FROM 
			tb_member AS m
		WHERE 
			m.m_id = #{memberId};
	</select>
	
	<!-- 회원 등급 조회 -->
	<select id="getMemberLevelList" resultMap="memberLevelResultMap">
		/* 회원등급조회 */
		SELECT
			l.level_num,
			l.level_name,
			l.level_reg_date
		FROM
			tb_member_level 	AS l;
	</select>
	
	<!-- 회원 목록 조회 -->
	<select id="getMemberList" resultType="Member">
		/* 회원목록 조회 */
		SELECT
			m.m_id 						AS memberId,
			m.m_pw 						AS memberPw,
			m.m_name 					AS memberName,
			IFNULL(m.m_level,0) 		AS memberLevel,
			l.level_name 				AS memberLevelName,
			m.m_email 					AS memberEmail,
			m.m_addr 					AS memberAddr,
			m.m_reg_date 				AS memberRegDate
		FROM
			tb_member as m
			INNER JOIN 
			tb_member_level as l
			ON 
			m.m_level = l.level_num
		ORDER BY memberId;
		<!-- order by로 id 순으로 정렬이 되게 설정, 본래는 level_num 순으로 정렬되어 있었음. -->
	</select>
</mapper>






